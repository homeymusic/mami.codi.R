### Estimating Spatiotemporal Periodicity

To estimate the periodicity of a chord, the MaMi.CoDi model uses a signal 
processing technique. It finds ratios, within a given tolerance, 
for every tone in the chord (fundamental, harmonics, noise, etc.) relative to 
a reference tone. The least common denominator of those ratios is a measure of the 
cycle length, relative to the reference tone. Long relative cycles are predicted 
to sound unpleasant and short relative cycles are predicted to sound pleasant. \

MaMi.CoDi creates two estimates of the chord's period: a temporal estimate and 
a spatial estimate.\

For the temporal (i.e. phase-locking or frequency) estimate the reference tone is the 
smallest frequency. Small frequencies are low tones and are detected by the inner 
ear hair cells closest to the apex of the cochlea, which is the end furthest from
the source of the wave.\

For the spatial (i.e. rate-place or wavelength) estimate, the reference tone is the 
smallest wavelength. Small wavelengths are high tones and are detected by the 
inner ear hair cells closest to the base of the cochlea, which is the end closest 
to the middle ear, the source of the wave. \

MaMi.CoDi combines the two cycle estimates into a two-dimensional space with 
consonance-dissonance along one dimension and major-minor on the orthogonal dimension.

#### Chord

Below, we estimate the periodicity of the C4, E4 and 
G4 major triad with 5 harmonics per pitch. The MaMi.CoDi model is based on 
ratios of tones - both frequency and wavelength ratios. The input to the model 
is a sparse frequency spectrum. We convert frequencies to wavelengths by 
dividing a speed of sound constant by the frequency.\

For tone ratios, the value of the speed of sound constant does not impact the 
mathematics. Ideally, we could choose any media for the speed of sound: 
air, cochlear fluid, basilar membrane, etc. 

However, for calculations in a computer, the constant does make a difference because 
of the way computers handle very small and very large numbers. So, we chose a 
constant for each chord that ensures the wavelength and frequency values
are in the same range. Choosing a constant that gives similar ranges for 
frequencies and wavelengths makes it easier to see how different the ratios for the
two signals will be.

```{r, echo=F, results='asis', message=F}
midi  = c(0, 4, 7) + 60
tolerance = 1e-01
num_harmonics = 5
chord = midi %>% mami.codi(
  tolerance  = tolerance,
  verbose=T,
  num_harmonics = num_harmonics
)
```

* Fundamentals in MIDI: `r midi`\

* Number of Harmonics: `r num_harmonics`

* Frequencies: `r sprintf(chord$frequencies[[1]], fmt = '%#.1f')`\

* Wavelengths: `r sprintf(chord$wavelengths[[1]], fmt = '%#.1f')`\

* Speed of Sound: `r sprintf(chord$speed_of_sound, fmt = '%#.1f')`

#### Temporal Estimate
```{r, echo=F, results='asis', message=F}
knitr::kable(tibble::tibble(
  tol    = chord$tolerance,
  min_f_Hz = min(chord$frequencies[[1]]),
  max_f_Hz = max(chord$frequencies[[1]]),
  chord_Sz = chord$frequency_lcd,
  chord_Hz = min_f_Hz / chord_Sz,
  chord_s  = 1 / chord_Hz,
  chord_m  = SPEED_OF_SOUND / chord_Hz
) %>% dplyr::select(chord_Hz, chord_m, chord_s, chord_Sz, tol))
```

##### Periods

```{r, echo=F, results='asis', message=F}
ratios = chord$frequency_ratios[[1]] %>% 
  dplyr::select(index, num, den, tone)
lcd    = chord$frequency_lcd
plot_periodicity(ratios, lcd, 'frequency', relative = F)
```

##### Relative Periodicity

```{r, echo=F, results='asis', message=F}
plot_periodicity(ratios, lcd, 'frequency')
```

#### Frequency Ratios
```{r, echo=F, results='asis', message=F}
knitr::kable(chord$frequency_ratios[[1]] %>% dplyr::arrange(ratio) %>% dplyr::select(-pseudo_ratio))
```

#### Spatial Estimate
```{r, echo=F, results='asis', message=F}
knitr::kable(tibble::tibble(
  tol      = chord$tolerance,
  min_l_m  = min(chord$wavelengths[[1]]),
  max_l_m  = max(chord$wavelengths[[1]]),
  chord_Sz = chord$wavelength_lcd,
  chord_m  = min_l_m * chord_Sz,
  chord_s  = chord_m / SPEED_OF_SOUND * (max_l_m / min_l_m),
  chord_Hz = 1 / chord_s,
) %>% dplyr::select(chord_Hz, chord_m, chord_s, chord_Sz, tol))
```

##### Spatial Frequency

```{r, echo=F, results='asis', message=F}
ratios = chord$wavelength_ratios[[1]] %>%
  dplyr::select(index, num, den, tone)
lcd    = chord$wavelength_lcd
plot_periodicity(ratios, lcd, 'wavelength', c_sound = chord$speed_of_sound,relative = F)
```

##### Relative Spatial Frequency

```{r, echo=F, results='asis', message=F}
plot_periodicity(ratios, lcd, 'wavelength', c_sound = chord$speed_of_sound)
```

##### Wavelength Ratios
```{r, echo=F, results='asis', message=F}
knitr::kable(chord$wavelength_ratios[[1]] %>% dplyr::arrange(ratio) %>% dplyr::select(-pseudo_ratio))
```
