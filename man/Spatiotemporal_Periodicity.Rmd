```{r, echo=F, message=F, include=F}
devtools::load_all(".")
source('./man/code/plot.R')
source('./man/code/utils.R')
knitr::opts_chunk$set(
 collapse = TRUE,
 comment = "#>",
 fig.path = "man/figures/README-",
 warning = FALSE,
 message = FALSE
)
midi  = c(0, 4, 7) + 60
num_harmonics = 3
```

### Estimating Spatiotemporal Periodicity

To estimate the periodicity of a chord, the MaMi.CoDi model uses a signal 
processing technique. It finds fractions, within a given variance, 
for every tone in the chord (fundamental, harmonics, noise, etc.) relative to 
a reference tone. The least common denominator of those fractions is a measure of the 
cycle length, relative to the reference tone. Long relative cycles are predicted 
to sound unpleasant and short relative cycles are predicted to sound pleasant. \

MaMi.CoDi creates two estimates of the chord's period: a temporal estimate and 
a spatial estimate.\

For the temporal (i.e. phase-locking or frequency) estimate the reference tone is the 
smallest frequency. Small frequencies are low tones and are detected by the inner 
ear hair cells closest to the apex of the cochlea, which is the end furthest from
the source of the wave.\

For the spatial (i.e. rate-place or wavelength) estimate, the reference tone is the 
smallest wavelength. Small wavelengths are high tones and are detected by the 
inner ear hair cells closest to the base of the cochlea, which is the end closest 
to the middle ear, the source of the wave. \

MaMi.CoDi combines the two cycle estimates into a two-dimensional space with 
consonance-dissonance along one dimension and major-minor on the orthogonal dimension.

#### Example Chord: Major Triad

Below, we estimate the periodicity of the C4, E4 and G4 major triad 
with `r num_harmonics` harmonics per pitch. The MaMi.CoDi model is based on 
fractions of tones - both frequency and wavelength fractions. The input to the model 
is a sparse frequency spectrum. We convert frequencies to wavelengths by 
dividing a speed of sound constant by the frequency.\

For tone fractions, the value of the speed of sound constant does not impact the 
mathematics. Ideally, we could choose any media for the speed of sound: 
air, cochlear fluid, basilar membrane, etc. 

However, for calculations in a computer, the constant does make a difference because 
of the way computers handle very small and very large numbers. So, we chose a 
constant for each chord that ensures the wavelength and frequency values
are in the same range. Choosing a constant that gives similar ranges for 
frequencies and wavelengths makes it easier to see how different the fractions for the
two signals will be.

```{r, echo=F, results='asis', message=F}
chord = midi %>% mami.codi(
  verbose=T,
  num_harmonics = num_harmonics
)
c_sound = chord$speed_of_sound
```

* Fundamentals in MIDI: `r midi`\

* Number of Harmonics: `r num_harmonics`

* Frequencies: `r sprintf(chord$frequencies[[1]], fmt = '%#.1f')`\

* Speed of Sound: `r sprintf(c_sound, fmt = '%#.1f')`

* Wavelengths: `r sprintf(chord$wavelengths[[1]], fmt = '%#.1f')`\

###### MaMi.CoDi Predictions
```{r, echo=F, results='asis', message=F}
knitr::kable(chord %>% dplyr::select('consonance_dissonance', 'major_minor', 'temporal_consonance', 'spatial_consonance'))
```

#### Temporal Periodicity
```{r, echo=F, results='asis', message=F}
knitr::kable(tibble::tibble(
  tol      = chord$variance,
  lcd      = chord$temporal_alcd,
  chord_Sz = log2(lcd),
  min_f_Hz = min(chord$frequencies[[1]]),
  max_T_s  = 1 / min_f_Hz,
  chord_s  = lcd * max_T_s,
  chord_Hz = 1 / chord_s,
  chord_m  = c_sound / chord_Hz,
  c_sound
) %>% dplyr::select(lcd, chord_Sz, chord_Hz, c_sound, chord_m, chord_s, tol))
```

##### Partial Periods

```{r, echo=F, results='asis', message=F}
fractions = chord$temporal_fractions[[1]] %>% 
  dplyr::select(num, den, rational_number)
lcd    = chord$temporal_alcd
plot_periodicity(fractions, lcd, 'frequency', relative = F)
```

##### Chord Period

```{r, echo=F, results='asis', message=F}
plot_periodicity(fractions, lcd, 'frequency')
```

##### Frequency fractions
```{r, echo=F, results='asis', message=F}
knitr::kable(chord$temporal_fractions[[1]] %>% 
               dplyr::arrange(fraction) %>% 
               dplyr::rename(
                 tone_hz = rational_number
               ))
```

#### Spatial Periodicity
```{r, echo=F, results='asis', message=F}
knitr::kable(tibble::tibble(
  tol      = chord$variance,
  lcd      = chord$spatial_alcd,
  chord_Sz = log2(lcd),
  max_l_m  = max(chord$wavelengths[[1]]),
  chord_m  = lcd * max_l_m,
  chord_Hz = c_sound / chord_m,
  chord_s  = 1 / chord_Hz,
  c_sound
) %>% dplyr::select(lcd, chord_Sz, chord_Hz, c_sound, chord_m, chord_s, tol))
```

##### Partial Wavelengths

```{r, echo=F, results='asis', message=F}
fractions = chord$spatial_fractions[[1]] %>%
  dplyr::select(index, num, den, rational_number)
lcd    = chord$spatial_alcd
plot_periodicity(fractions, lcd, 'wavelength', c_sound = c_sound,relative = F)
```

##### Chord Wavelength

```{r, echo=F, results='asis', message=F}
plot_periodicity(fractions, lcd, 'wavelength', c_sound = c_sound)
```

##### Wavelength fractions
```{r, echo=F, results='asis', message=F}
knitr::kable(chord$spatial_fractions[[1]] %>% 
               dplyr::arrange(ratio) %>% 
               dplyr::rename(
                 tone_m = rational_number
               ))
```
